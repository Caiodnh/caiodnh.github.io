<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Seno" />
  <title>Monads are machines: an intuitive introduction to monads</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Monads are machines: an intuitive introduction to monads</h1>
<p class="author">Seno</p>
<p class="date">October, 2021</p>
</header>
<table style="width:96%;">
<colgroup>
<col style="width: 95%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>WARNING!!!</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">What follows is full of vague statements meant to COMPLEMENT the actual formal notions with some intuition, hence improving understatement. These statements ARE NOT what the concepts are in a strict sense and should not be used in any serious argument. The readers MUST be comfortable with ill-defined notions appealing to their subjective experience of the world, as well as keep pedantic comments to themselves.</td>
</tr>
</tbody>
</table>
<p><strong>REQUISITES:</strong></p>
<ul>
<li>Formally speaking, the reader must know only some basic Haskell, including classes and type and data constructors. Of course, having some experience helps.</li>
<li>Our main example is an interpreter of a very simple lambda-calculus, but it is very easy to learn.</li>
<li>We will not use any earlier knowledge of functors nor applicatives.</li>
</ul>
<h1 id="introduction">Introduction</h1>
<p>Most texts introducing monads present no intuition at all. This is related to a way to see mathematics (including computer science as a part of it) as a purely formal matter, and even though when talking to mathematicians they give informal insights on how to think about the things they write, those insights never get to the text. We believe this is foolish, and good intuitions are fundamental, even at the cost of looking like people from the arts department (<em>argh!</em>). We still believe that in the end of the day the formal part is what matters, but the informal is very fruitful in the morning, afternoon and even early evening.</p>
<p>Having said that, usually the intuitions presented to explain monads are to vague to capture its essence. Some people talk about “containers,” others about “computations.” Well, we are mixing both and talk about “<a href="#monads-as-machines">machines</a>.” And we believe this works quite well.</p>
<p>This metaphor came to us after looking different sources to try to have a better grasp of what monads really mean, which led us to, desperately, check the original papers on the subject. Monads were first (at least, explicitly) introduced in computer science by Moggi <span class="citation" data-cites="Mog89">[1]</span> in 1989. But not only this is a very technical paper, it uses monads as tool to analyse lambda calculus rather than a tool to write code. This second part came 1990, with a much more accessible paper by Waddler <span class="citation" data-cites="Wad90">[2]</span>, who also wrote a paper in 1992 <span class="citation" data-cites="Wad92">[3]</span> with a second approach to introduce monads for programmers. What we are doing here is basically rewriting part of this latter paper, with few of twists: * We are introducing our monad as machine metaphor; * We are adapting the code to the current way Haskell is written; * We prefer to introduce the monad class via the <em>join</em> function rather than <em>bind</em>, but we go back to the <a href="#def-with-bind">standard way</a> as fast as possible; * We do not follow the full paper, only the first few sections, which are the ones that explain monads. We also changed the order of the examples presented, because we believe some are more <a href="#main-examples">important</a> than <a href="#more-examples">others</a>.</p>
<p>Let’s start with an excerpt of that paper’s introduction:</p>
<blockquote>
<p>Say I write an interpreter in a pure functional language.</p>
<p>To add <a href="#machine-error">error handling</a> to it, I need to modify the result type to include error values, and at each recursive call to check for and handle errors appropriately. Had I used an impure language with exceptions, no such restructuring would be needed.</p>
<p>To add an <a href="#machine-count">execution count</a> to it, I need to modify the the result type to include such a count, and modify each recursive call to pass around such counts appropriately. Had I used an impure language with a global variable that could be incremented, no such restructuring would be needed.</p>
<p>To add an <a href="#machine-output">output instruction</a> to it, I need to modify the result type to include an output list, and to modify each recursive call to pass around this list appropriately. Had I used an impure language that performed output as a side effect, no such restructuring would be needed.</p>
<p>Or I could use a <em>monad</em>.</p>
</blockquote>
<h1 id="the-abstract-notion-of-monad">The Abstract Notion of Monad</h1>
<p>We will now introduce monads both formally and informally.</p>
<p>We believe many readers tried to understand monads before and, hence, know a couple of examples. Well, it is better to keep these previously know examples at bay for now, so they don’t mess up with the intuitions we are trying to build up in this section. Most of all, the list monad may seem very unrelated, but we will <a href="#main-examples">get back to it</a>.</p>
<h2 id="monads-as-machines">The monad class</h2>
<p>As we said above, we chose to differ from the usual way that Haskell does, because we believe this other (well-known) approach makes it easier to understand. The way that is currently done in Haskell will be presented <a href="#def-with-bind">soon after</a>, so we do not lose touch with reality.</p>
<p>A price to pay for this, is that we have hide part of the <code>Prelude</code>, so we use the <code>NoImplicitPrelude</code> extension. We also use other two not verry important language extensions only for convenience when writing our <a href="#main-examples">examples</a>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">{-\# LANGUAGE NoImplicitPrelude, InstanceSigs, FlexibleInstances #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (<span class="dt">Functor</span>, <span class="dt">Monad</span>, fmap, return, (&gt;&gt;=), lookup)</span></code></pre></div>
<p>Ok, now we are ready to define the <code>Monad</code> class:</p>
<p>COMENTÁRIO: Talvez devesse ser uma <code>Machine</code> class e depois definir mônadas a partir dela? Mas para isso a gente teria que escrever <code>returnM</code>, <code>joinM</code> e <code>fmapM</code>. Enfim, fica a dúvida.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  return ::</span> a <span class="ot">-&gt;</span>  m a</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  join ::</span> m (m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b</span></code></pre></div>
<p>The intuition behind is that monads represent machines that can perform computations differently from the standard way Haskell would.</p>
<p><code>return</code>: Any haskell value, of any type, can be interpreted as a value written in the machine’s “internal representation” of that type.</p>
<p><code>join</code>: It is easy for the machine to “emulate itself”: if we have a “machine code written in machine code,” the machine can remove one of the layers and see it as simply “machine code.”</p>
<p><code>fmap</code>: Any “vanilla” Haskell function can be translated into a function that deals with values written in “machine code.”</p>
<p>For an instance of this class be called a monad, there are laws that are expected to be valid. They are very natural with this machine metaphor. For example, one would expect that if we have a value <code>x</code> with type <code>m a</code> for some <code>a</code> (these are called <em>monadic values</em>), then <code>join (return x) = x</code> (in other words, that if we take something already in machine code and write it in machine code again, well, the machine can ignore this second layer). As another example, now for any value <code>x :: a</code> and any function <code>f :: a -&gt; b</code> , one would expect that <code>fmap f (return x)</code> should be the same as <code>return (f x)</code> (performing a computation out of the machine, if possible, is compatible with performing it inside). We will postpone listing all the laws for another moment, to avoid losing our focus (see http://xenon.stanford.edu/~hwatheod/monads.html).</p>
<p>While an element of type <code>Int</code> is what Haskell calls an integer, an element of type <code>m Int</code> is what the machine calls an integer. Starting from the <code>2 :: Int</code>, we then have that <code>return 2 :: m Int</code> is a representation of the integer 2. But, and this is an important point, the machine can have elements of type <code>m Int</code> which are not achivable via <code>return</code>. One machine could call as an <code>m Int</code> something like “whatever integer is in this position of the memory when I read it,” or “an integer that will be typed by the user,” or “something that, if nothing goes wrong, will end up being an integer.” We can say that the <code>return 2</code> means something like “the most basic representation the machine can have for the integer 2,” or “the pure integer 2” or even “the constant integer 2.” We will see different examples of monads shortly, so this will get clearer, but for now the goal is still to develop an intuition of what a monad is in general terms.</p>
<p>From what we just said, it is not surprising that, in general, one cannot read a what it is inside an <code>m a</code> and put it back in the vanilla type <code>a</code>. Once a value enters the machine, it will be in the machine forever (well, there are exceptions, but that is usually the case). In the examples we will show below, there is a <code>show</code> function with signature <code>show :: m a -&gt; String</code>, so at least we can see what is going on, but not even this is necessary.</p>
<h2 id="monadic-functions-and-bind">Monadic functions and bind</h2>
<p>Most of the time, we communicate with a machine using functions that read “vanilla” values but produce values in “machine code,” e.g., functions with signature <code>a -&gt; m b</code> or <code>a -&gt; b -&gt; m c</code> in opposition to functions with signature <code>a -&gt; b</code> or <code>a -&gt; b -&gt; c</code>. We will call these <em>monadic functions</em>. These are easy to write, since, again, we know how to put vanilla values into the machine but not the reverse.</p>
<p>(Formally speaking, we can define a <em>monadic function signature</em> to be any type <code>a -&gt; x</code> where x is either of the form <code>m b</code> or it is, recursively, a monadic function signature.)</p>
<p>A very common situation is when we have a monadic value with type <code>m a</code>, for some <code>a</code> and want to pass it to a monadic function of type <code>a -&gt; m b</code>. How could we do it? Well, we can’t remove the <code>a</code> from inside the <code>m a</code>, but we can use the ability of the machine to “emulate itself!” The strategy is the following: we first use the <code>fmap</code> on our monadic function to get something with type <code>m a -&gt; m (m b)</code>; we then it apply to our monadic value and get something with type <code>m (m b)</code>; finally, we resolve the redundancy of having an extra <code>m</code> by applying <code>join</code>. In other words, we use:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>m_val <span class="op">&gt;&gt;=</span> m_func <span class="ot">=</span> join (<span class="fu">fmap</span> m_func m_val)</span></code></pre></div>
<p>This function is called <em>bind</em>. It is so powerful that we could have used it and <code>return</code> to define <code>join</code> and <code>fmap</code> instead of how we did. Actually, the default definition of the monad class in Haskell, which we avoided above, is using <code>return</code> and <code>(&gt;&gt;=)</code>! At this point, we could go back and remove the <code>{-# LANGUAGE NoImplicitPrelude #-}</code> and the <code>import Prelude hiding</code> but, still, we believe would make our machine metaphor more obscure.</p>
<p>By design, bind doesn’t follow the usual function application notation, <code>f x</code>, with the function on the left and the value on the right. And,indeed, there is a function <code>(=&lt;&lt;)</code> which follows this convention. But <code>(&gt;&gt;=)</code> is more common because it follows the order things usually happen: we have a value, then apply a function, get another value, pass it to another function, etc. This sequencing is something that agrees with the way many “machines” actually work.</p>
<p>Another strange thing is this name “bind.” The intuition is that, although we can’t read the internal value an <code>m a</code>, we can “bind its value” to the variable that we pass to the function <code>a -&gt; m b</code>. This intuition will make more sense when we work with the <em>do notation</em>. But, we had enough general considerations. Let’s put our hands on an example.</p>
<h2 id="def-with-bind">Back to reality: how Haskell do it</h2>
<h1 id="concrete-examples">Concrete examples</h1>
<p>This is call-by-value, for a call-by-name, see <span class="citation" data-cites="Wad92">[3, Subsection 2.9]</span>.</p>
<p>To avoid confusing technicalities, we will assume we have a constant monad <code>M</code>, that we will choose which of the monads we will present below by commenting/uncommenting the obvious lines of code.</p>
<h2 id="representing-our-lambda-calculus-in-haskell">Representing our lambda calculus in Haskell</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- The `Name` type consists of the names we can give to our variables.</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Name</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- The terms of our simple lambda-calculus are constructed from Ints or free variables by using addition or lambda-abstraction.</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> <span class="ot">=</span> <span class="dt">Con</span> <span class="dt">Int</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Var</span> <span class="dt">Name</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Term</span> <span class="dt">Term</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Name</span> <span class="dt">Term</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">App</span> <span class="dt">Term</span> <span class="dt">Term</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- Each term is interpreted into a `Value` by a machine (monad) `m`.</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Value</span> <span class="ot">=</span> <span class="dt">Wrong</span> </span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>           <span class="op">|</span> <span class="dt">Num</span> <span class="dt">Int</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>           <span class="op">|</span> <span class="dt">Fun</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">M</span> <span class="dt">Value</span>)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- Note that lambda-terms are interpreted as monadic functions `Value -&gt; M Value` and not as functions `Value -&gt; Value`. This is so we can use these functions to interact with the &quot;machine&quot; using bind.</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- If we have free variables, we need to bind them to values before evaluating the term.</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Environment</span> <span class="ot">=</span> [(<span class="dt">Name</span>, <span class="dt">Value</span>)]</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- ## Instances</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Value</span> <span class="kw">where</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> <span class="dt">Wrong</span>   <span class="ot">=</span> <span class="st">&quot;&lt;wrong&gt;&quot;</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">Num</span> i) <span class="ot">=</span> <span class="fu">show</span> i</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">Fun</span> f) <span class="ot">=</span> <span class="st">&quot;&lt;function&gt;&quot;</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="co">-- ## Functions defining the interpreter</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a><span class="co">-- All monadic functions, even though we don&#39;t need them all to be.</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span><span class="ot"> ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Environment</span> <span class="ot">-&gt;</span> <span class="dt">M</span> <span class="dt">Value</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> x []        <span class="ot">=</span> <span class="fu">return</span> <span class="dt">Wrong</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> x ((y,b)<span class="op">:</span>e) <span class="ot">=</span> <span class="kw">if</span> x<span class="op">==</span>y</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">then</span> <span class="fu">return</span> b</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">else</span> <span class="fu">lookup</span> x e</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">M</span> <span class="dt">Value</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>add (<span class="dt">Num</span> i) (<span class="dt">Num</span> j) <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> <span class="dt">Num</span> (i<span class="op">+</span>j)</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>add _ _ <span class="ot">=</span> <span class="fu">return</span> <span class="dt">Wrong</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a><span class="ot">apply ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">M</span> <span class="dt">Value</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>apply (<span class="dt">Fun</span> f) a <span class="ot">=</span> f a</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>apply _ _ <span class="ot">=</span> <span class="fu">return</span> <span class="dt">Wrong</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a><span class="ot">interp ::</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Environment</span> <span class="ot">-&gt;</span> <span class="dt">M</span> <span class="dt">Value</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>interp (<span class="dt">Con</span> i) e <span class="ot">=</span> <span class="fu">return</span> (<span class="dt">Num</span> i)</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>interp (<span class="dt">Var</span> x) e <span class="ot">=</span> <span class="fu">lookup</span> x e</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>interp (<span class="dt">Add</span> u v) e <span class="ot">=</span> interp u e <span class="op">&gt;&gt;=</span></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>                      (\a <span class="ot">-&gt;</span> interp v e <span class="op">&gt;&gt;=</span></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>                        \b <span class="ot">-&gt;</span> add a b)</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>interp (<span class="dt">Lam</span> x v) e <span class="ot">=</span> <span class="fu">return</span> (<span class="dt">Fun</span> (\a <span class="ot">-&gt;</span> interp v ((x,a)<span class="op">:</span>e)))</span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>interp (<span class="dt">App</span> t u) e <span class="ot">=</span> interp t e <span class="op">&gt;&gt;=</span> (\f <span class="ot">-&gt;</span> interp u e <span class="op">&gt;&gt;=</span> \a <span class="ot">-&gt;</span> apply f a)</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>test t <span class="ot">=</span> <span class="fu">show</span> (interp t [])</span></code></pre></div>
<h2 id="main-examples">Main examples</h2>
<h3 id="machine-0-identity">Machine 0: Identity</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">M</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Id</span> a <span class="ot">=</span> <span class="dt">Id</span> a</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Id</span> <span class="kw">where</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">Id</span> a</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  join (<span class="dt">Id</span> (<span class="dt">Id</span> a)) <span class="ot">=</span> <span class="dt">Id</span> a</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Id</span> a) <span class="ot">=</span> <span class="dt">Id</span> (f a)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Id</span> a) <span class="kw">where</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">Id</span> a) <span class="ot">=</span> <span class="fu">show</span> a</span></code></pre></div>
<h3 id="machine-errors">Machine 1: Error Messages</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- type M = E</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">E</span> a <span class="ot">=</span> <span class="dt">Error</span> <span class="dt">String</span> <span class="op">|</span> <span class="dt">Success</span> a </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">E</span> <span class="kw">where</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  return ::</span> a <span class="ot">-&gt;</span> <span class="dt">E</span> a</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">Success</span> a</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  join ::</span> <span class="dt">E</span> (<span class="dt">E</span> a) <span class="ot">-&gt;</span> <span class="dt">E</span> a</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  join (<span class="dt">Success</span> (<span class="dt">Success</span> a)) <span class="ot">=</span> <span class="dt">Success</span> a</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  join (<span class="dt">Success</span> (<span class="dt">Error</span> msg)) <span class="ot">=</span> <span class="dt">Error</span> msg</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  join (<span class="dt">Error</span> msg)           <span class="ot">=</span> <span class="dt">Error</span> msg</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">E</span> a <span class="ot">-&gt;</span> <span class="dt">E</span> b</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Success</span> a) <span class="ot">=</span> <span class="dt">Success</span> (f a)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Error</span> msg) <span class="ot">=</span> <span class="dt">Error</span> msg</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">E</span> a) <span class="kw">where</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">Success</span> a) <span class="ot">=</span> <span class="fu">show</span> a</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">Error</span> msg) <span class="ot">=</span> <span class="st">&quot;ERROR! &quot;</span> <span class="op">++</span> msg</span></code></pre></div>
<p>Changes to the interpreter:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> x [] <span class="ot">=</span> errorE (<span class="st">&quot;Unbound variable: &quot;</span> <span class="op">++</span> x)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>add a b <span class="ot">=</span> errorE (<span class="st">&quot;Should be numbers: &quot;</span> <span class="op">++</span> <span class="fu">show</span> a <span class="op">++</span> <span class="st">&quot;,&quot;</span> <span class="op">++</span> <span class="fu">show</span> b)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>apply f a <span class="ot">=</span> errorE (<span class="st">&quot;Should be a function: &quot;</span> <span class="op">++</span> <span class="fu">show</span> f)</span></code></pre></div>
<h3 id="machine-count">Machine 2: State</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">StateMachine</span> state a <span class="ot">=</span> <span class="dt">SM</span> (state <span class="ot">-&gt;</span> (a, state))</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">StateMachine</span> state) <span class="kw">where</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  return ::</span> a <span class="ot">-&gt;</span> <span class="dt">StateMachine</span> state a</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">SM</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> (a, s)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  join ::</span> <span class="dt">StateMachine</span> state (<span class="dt">StateMachine</span> state a) <span class="ot">-&gt;</span> <span class="dt">StateMachine</span> state a</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  join (<span class="dt">SM</span> metaMachine) <span class="ot">=</span> <span class="dt">SM</span> newMachine</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>      newMachine s0 <span class="ot">=</span> <span class="kw">let</span> (<span class="dt">SM</span> machine, s1) <span class="ot">=</span> metaMachine s0 <span class="kw">in</span> machine s1</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">StateMachine</span> state a <span class="ot">-&gt;</span> <span class="dt">StateMachine</span> state b</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">SM</span> machine) <span class="ot">=</span> <span class="dt">SM</span> newMachine</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>      newMachine s0 <span class="ot">=</span> <span class="kw">let</span> (a, s1) <span class="ot">=</span> machine s0 <span class="kw">in</span> (f a, s1)</span></code></pre></div>
<p>More stuff:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- instance for show only for the case the `state` is taken to be Int</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CountingMachine</span> <span class="ot">=</span> <span class="dt">StateMachine</span> <span class="dt">Int</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">CountingMachine</span> a) <span class="kw">where</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">SM</span> machine) <span class="ot">=</span> <span class="kw">let</span> (a, s1) <span class="ot">=</span> machine <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>                      <span class="st">&quot;Value: &quot;</span> <span class="op">++</span> <span class="fu">show</span> a <span class="op">++</span> <span class="st">&quot;; &quot;</span> <span class="op">++</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>                      <span class="st">&quot;Count: &quot;</span> <span class="op">++</span> <span class="fu">show</span> s1</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- The typing of `tick` makes clear that the value returned is not of interest. It is analogous to the use in an impure language of a function with result type (), indicating that the purpose of the function lies in a side effect.</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="ot">tick ::</span> <span class="dt">CountingMachine</span> ()</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>tick <span class="ot">=</span> <span class="dt">SM</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> ((), s<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- If we want to read the current state, we can use:</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="ot">fetch ::</span> <span class="dt">StateMachine</span> state state</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>fetch <span class="ot">=</span> <span class="dt">SM</span> machine</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    machine s <span class="ot">=</span> (s, s)</span></code></pre></div>
<h3 id="machine-example">Machine 3: Output</h3>
<h3 id="machine-4-non-deterministic-choice">Machine 4: Non-deterministic choice</h3>
<h2 id="more-examples">More examples</h2>
<h3 id="machine-5-errors-with-position">Machine 5: Errors with position</h3>
<h3 id="machine-6-reverse-state">Machine 6: Reverse State</h3>
<h1 id="the-monad-laws">The monad laws</h1>
<h2 id="with-return-join-and-fmap">With <code>return</code>, <code>join</code> and <code>fmap</code></h2>
<h2 class="unnumbered" id="with-bind-monad-composition">With <code>bind</code>; Monad composition</h2>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-Mog89" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">1. </div><div class="csl-right-inline">Moggi, E.: Notions of computation and monads (Selections from 1989 IEEE Symposium on Logic in Computer Science). Information and Computation. 93, 55–92 (1991)</div>
</div>
<div id="ref-Wad90" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">2. </div><div class="csl-right-inline">Wadler, P.: Comprehending monads. In: Proceedings of the 1990 ACM conference on LISP and functional programming. pp. 61–78 (1990)</div>
</div>
<div id="ref-Wad92" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">3. </div><div class="csl-right-inline">Wadler, P.: The essence of functional programming. In: Proceedings of the 19th ACM SIGPLAN-SIGACT symposium on principles of programming languages. pp. 1–14 (1992)</div>
</div>
</div>
</body>
</html>
