<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Seno" />
  <title>Monads are machines: an intuitive introduction to monads</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Monads are machines: an intuitive introduction to monads</h1>
<p class="author">Seno</p>
<p class="date">November, 2021</p>
</header>
<table style="width:96%;">
<colgroup>
<col style="width: 95%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>WARNING!!!</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">What follows is full of vague statements meant to COMPLEMENT the actual formal notions with some intuition, hence improving understatement. These statements ARE NOT what the concepts are in a strict sense and should not be used in any serious argument. The readers MUST be comfortable with ill-defined notions appealing to their subjective experience of the world, as well as keep pedantic comments to themselves.</td>
</tr>
</tbody>
</table>
<p><strong>REQUISITES:</strong></p>
<ul>
<li>Formally speaking, the reader must know only some basic Haskell, including classes and type and data constructors. Of course, having some experience helps.</li>
<li>Our main example is an interpreter of a very simple lambda-calculus, but it is very easy to learn.</li>
<li>We will not use any earlier knowledge of <code>Functor</code> nor <code>Applicative</code>.</li>
</ul>
<h1 id="introduction">Introduction</h1>
<p>Most texts introducing monads present no intuition at all. This is related to a way to see mathematics (including computer science as a part of it) as a purely formal matter, and even though when talking to mathematicians they give informal insights on how to think about the things they write, those insights never get to the text. We believe this is foolish, and good intuitions are fundamental, even at the cost of looking like people from the arts department (<em>argh!</em>). We still believe that in the end of the day the formal part is what matters, but the informal is very fruitful in the morning, afternoon and even early evening.</p>
<p>Having said that, usually the intuitions presented to explain monads are to vague to capture its essence. Some people talk about “containers,” others about “computations.” Well, we are mixing both and talk about “<a href="#monads-as-machines">machines</a>.” And we believe this works quite well.</p>
<p>This metaphor came to us after looking different sources to try to have a better grasp of what monads really mean, which led us to, desperately, check the original papers on the subject. Monads were first (at least, explicitly) introduced in computer science by Moggi <span class="citation" data-cites="Mog89">[1]</span> in 1989. But not only this is a very technical paper, it uses monads as tool to analyse lambda calculus rather than a tool to write code. This second part came 1990, with a much more accessible paper by Waddler <span class="citation" data-cites="Wad90">[2]</span>, who also wrote a paper in 1992 <span class="citation" data-cites="Wad92">[3]</span> with a second approach to introduce monads for programmers. What we are doing here is basically rewriting part of this latter paper, with few of twists:</p>
<ul>
<li>We are introducing our monad as machine metaphor;</li>
<li>We are adapting the code to the current way Haskell is written;</li>
<li>We prefer to introduce the Monad class via the <em>join</em> function rather than <em>bind</em>, but we go back to the <a href="#def-with-bind">standard way</a> as fast as possible; to this end, we create the <a href="#monads-as-machines"><code>Machine</code> class</a></li>
<li>We do not follow the full paper, only the first few sections, which are the ones that explain monads. We also changed the order of the examples presented, because we believe some are more <a href="#main-examples">important</a> than <a href="#more-examples">others</a>.</li>
</ul>
<p>You can download a source code to follow this article <a href="./monads_as_machines.hs">here</a>.</p>
<p>Let’s start with an excerpt of that paper’s introduction:</p>
<blockquote>
<p>Say I write an interpreter in a pure functional language.</p>
<p>To add <a href="#machine-error">error handling</a> to it, I need to modify the result type to include error values, and at each recursive call to check for and handle errors appropriately. Had I used an impure language with exceptions, no such restructuring would be needed.</p>
<p>To add an <a href="#machine-count">execution count</a> to it, I need to modify the the result type to include such a count, and modify each recursive call to pass around such counts appropriately. Had I used an impure language with a global variable that could be incremented, no such restructuring would be needed.</p>
<p>To add an <a href="#machine-output">output instruction</a> to it, I need to modify the result type to include an output list, and to modify each recursive call to pass around this list appropriately. Had I used an impure language that performed output as a side effect, no such restructuring would be needed.</p>
<p>Or I could use a <em>monad</em>.</p>
</blockquote>
<h1 id="the-abstract-notion-of-monad">The Abstract Notion of Monad</h1>
<p>We will now introduce monads both formally and informally.</p>
<p>We believe many readers tried to understand monads before and, hence, know a couple of examples. Well, it is better to keep these previously know examples at bay for now, so they don’t mess up with the intuitions we are trying to build up in this section. Most of all, the list monad may seem very unrelated, but we will <a href="#main-examples">get back to it</a>.</p>
<h2 id="monads-as-machines">The <code>Machine</code> class</h2>
<p>As we said above, we chose to differ from the usual way that Haskell does, because we believe this other (well-known) approach makes it easier to understand. Actually, this is the approach usually followed in Category Theory, and was the one proposed in <span class="citation" data-cites="Wad90">[2]</span>.</p>
<p>To not mess things up and redefine the <code>Monad</code> class (and also to reinforce our analogy) we will define a new class called <code>Machine</code>. The functions in this class already exist in Haskell, so we will add an “M” to their names to avoid conflicts.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Machine</span> m <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  returnM ::</span> a <span class="ot">-&gt;</span>  m a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  joinM ::</span> m (m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  fmapM ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b</span></code></pre></div>
<p>The idea behind is the following:</p>
<p>While an element in <code>Integer</code> represents an integer for Haskell, an element in <code>m Integer</code> represents an integer written in the machine’s code.</p>
<p>The function <code>returnM</code> simply translates a value in Haskell to the same value written in machine code, e.g., if we take <code>2 :: Integer</code>, then <code>returnM 2 :: m Integer</code> is the way the machine represents the integer <code>2</code>.</p>
<p>Of course, this works for any of Haskell’s types, not only <code>Integer</code>. For every type <code>a</code>, there is a type <code>m a</code> that consists in the way the machine represents the elements of <code>a</code>. Since <code>m a</code> is itself an type in Haskell, there is an type <code>m (m a)</code>. The values with this type are “machine codes written in machine code.” Of course, this should be redundant: the machine should be able to emulate itself. And that is what the function <code>joinM</code> does.</p>
<p>Finally, Haskell functions can be used to handle machine code. Given a function <code>f</code> with signature <code>a -&gt; b</code>, there is a corresponding function that transform machine codes representing values of type <code>a</code> to machine codes representing values of type <code>b</code>.</p>
<p>We will refer to a value with type <code>m a</code> as an <em>monadic value</em> for short. Something important that we need to say is that, in general, not every monadic value can be constructed using <code>returnM</code>. An element of type <code>m Integer</code>, for instance, is something that is a integer for the standards of the machine <code>m</code>. It could be something like “whatever integer is in this position of the memory when I read it,” or “an integer that will be typed by the user,” or “some computation that, if nothing goes wrong, will end up being an integer.” We can think that the <code>returnM 2</code> means something like “the most basic representation the machine can have for the integer 2,” or “the pure integer 2” or even “the constant integer 2.”</p>
<p>Having said all that, there are also laws that we want the functions in the <code>Machine</code> class to follow. For example, one would expect that if we have a value <code>x</code> with type <code>m a</code> for some <code>a</code> (these are called <em>monadic values</em>), then <code>join (return x) = x</code> (in other words, that if we take something already in machine code and simply write it in machine code again, well, the machine can ignore this second layer). As another example, now for any value <code>x :: a</code> and any function <code>f :: a -&gt; b</code> , one would expect that <code>fmap f (return x)</code> should be the same as <code>return (f x)</code> (performing a computation out of the machine, if possible, is compatible with performing it inside). We will postpone listing all the laws for another moment, to avoid losing our focus (see <a href="http://xenon.stanford.edu/~hwatheod/monads.html">this link</a> for now).</p>
<h2 id="monadic-functions-and-bind">Monadic functions and bind</h2>
<p>From what we just said, it is not surprising that, in general, one cannot read a what it is inside an <code>m a</code> and put it back in the vanilla type <code>a</code>. Once a value enters the machine, it will be in the machine forever (well, there are exceptions, but that is usually the case). In the examples we will show below, there is a <code>show</code> function with signature <code>show :: m a -&gt; String</code>, so at least we can see what is going on, but not even this is necessary.</p>
<p>Most of the time, we communicate with a machine using functions that read “vanilla” values but produce values in “machine code,” e.g., functions with signature <code>a -&gt; m b</code> or <code>a -&gt; b -&gt; m c</code> in opposition to functions with signature <code>a -&gt; b</code> or <code>a -&gt; b -&gt; c</code>. We will call these <em>monadic functions</em>. These are easy to write, since, again, we know how to put vanilla values into the machine but not the reverse.</p>
<p>(Formally speaking, we can define a <em>monadic function signature</em> to be any type <code>a -&gt; x</code> where x is either of the form <code>m b</code> or it is, recursively, a monadic function signature.)</p>
<p>A very common situation is when we have a monadic value with type <code>m a</code> and want to pass it to a monadic function with type <code>a -&gt; m b</code>. How could we do it? Well, we can’t remove the <code>a</code> from inside the <code>m a</code>, but we can use the ability of the machine to “emulate itself!” The strategy is the following: we first use the <code>fmapM</code> on our monadic function to get something with type <code>m a -&gt; m (m b)</code>; we then it apply to our monadic value and get something with type <code>m (m b)</code>; finally, we resolve the redundancy of having an extra <code>m</code> by applying <code>join</code>. In other words, we use:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bindM ::</span> (<span class="dt">Machine</span> m) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>bindM m_val m_func <span class="ot">=</span> joinM (fmapM m_func m_val)</span></code></pre></div>
<p>This function is called <em>bind</em>. It is so powerful that we could have used it and <code>returnM</code> to define <code>joinM</code> and <code>fmapM</code> instead of how we did. Actually, that is the <a href="#def-with-bind">default way in Haskell</a>.</p>
<p>By design, bind doesn’t follow the usual function application notation, <code>f x</code>, with the function on the left and the value on the right. And, of course, there is a function in Haskell which follows the function application convention. But <code>bindM</code> is more common because it follows the order things usually happen: we have a value, then apply a function, get another value, pass it to another function, etc. This sequencing is something that agrees with the way many “machines” actually work.</p>
<p>Another strange thing is this name “bind.” The intuition is that, although we can’t read the internal value an <code>m a</code>, we can “bind its value” to the variable that we pass to the function <code>a -&gt; m b</code>. To explain it better, let us “translate” two examples into words.</p>
<p>The first is very simple: suppose we have an integer in machine code, i.e., an value <code>m_x</code> with type <code>m Integer</code> and we want to pass it to the function <code>\x -&gt; return (x + 1)</code>, which has type <code>Integer -&gt; m Integer</code>. We do</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>m_x <span class="ot">`bindM`</span> (\x <span class="ot">-&gt;</span> returnM (x <span class="op">+</span> <span class="dv">1</span>))</span></code></pre></div>
<p>which can be read as “Let <code>x</code> be the integer encoded by <code>m_x</code>. Add <code>1</code> to <code>x</code> and return the result to the machine.”</p>
<p>For an harder example, we will define the function <code>apM</code>, which corresponds to the function <code>ap</code> in <code>Control.Monad</code>. This function receives an “encoded” function <code>m_f</code> and an “encoded” value <code>m_x</code> and gives us the “machine code” of the value we would get by applying the function to the value:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">apM ::</span> (<span class="dt">Machine</span> m) <span class="ot">=&gt;</span> m (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>apM m_f m_x <span class="ot">=</span> m_f <span class="ot">`bindM`</span> (\f <span class="ot">-&gt;</span> m_x <span class="ot">`bindM`</span> (\x <span class="ot">-&gt;</span> returnM (f x)))</span></code></pre></div>
<p>which can be read as “Let <code>f</code> be the function encoded by <code>m_f</code>. Then let <code>x</code> be the value encoded by <code>m_x</code>. Then compute <code>f x</code> and return the resulting value to the machine.”</p>
<p>It may sound strange to use variables of functions for a “let” statement. But the usual <code>let</code> in Haskell can be interpreted as a function application: <code>let x = a in expression</code> is the same as “change all the occurrences of <code>x</code> to <code>a</code> in <code>expression</code>,” which is the same as <code>(\x -&gt; expression) a</code>. The strangeness comes from the fact that we usually think of the <code>x</code> in <code>let x = a</code> as an constant. But what is an constant if not an variable with a value assigned to it? Well, assigning a value to a variable is precisely what function application does.</p>
<p>If it is not clear now, there is no need to overthink, since we will see more examples below. Also, it is worth to say that this interpretation of <code>bindM</code> will get more explicit with the <em>do notation</em>.</p>
<h2 id="def-with-bind">Back to reality: how Haskell do it</h2>
<p>The moment to translate <code>Machine</code> to the way that the <code>Monad</code> class currently defined in Haskell has finally arrived! It has some layers: for a type constructor to have an instance of <code>Monad</code>, it needs an instance of <code>Applicative</code>, which in turn needs an instance of <code>Functor</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Machine</span> m <span class="ot">=&gt;</span> <span class="dt">Functor</span> m <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> <span class="ot">=</span> fmapM</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Machine</span> m <span class="ot">=&gt;</span> <span class="dt">Applicative</span> m <span class="kw">where</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="ot">=</span> returnM</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> apM</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Machine</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="ot">=</span> returnM</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  (<span class="op">&gt;&gt;=</span>) <span class="ot">=</span> bindM</span></code></pre></div>
<p>The reverse:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Machine</span> m <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  returnM <span class="ot">=</span> <span class="fu">return</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  joinM (mm_x) <span class="ot">=</span> mm_x <span class="op">&gt;&gt;=</span> <span class="fu">id</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  fmapM f m_x <span class="ot">=</span> m_x <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> <span class="fu">return</span> (f x))</span></code></pre></div>
<h1 id="concrete-examples">Concrete examples</h1>
<p>This is call-by-value, for a call-by-name, see <span class="citation" data-cites="Wad92">[3, Subsection 2.9]</span>.</p>
<p>To avoid confusing technicalities, we will assume we have a constant monad <code>M</code>, that we will choose which of the monads we will present below by commenting/uncommenting the obvious lines of code.</p>
<h2 id="representing-our-lambda-calculus-in-haskell">Representing our lambda calculus in Haskell</h2>
<h3 id="types">Types</h3>
<p>The <code>Name</code> type consists of the names we can give to our variables.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Name</span> <span class="ot">=</span> <span class="dt">String</span></span></code></pre></div>
<p>The terms of our simple lambda-calculus are constructed from Ints or free variables by using addition or lambda-abstraction.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> <span class="ot">=</span> <span class="dt">Con</span> <span class="dt">Int</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Var</span> <span class="dt">Name</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Term</span> <span class="dt">Term</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Name</span> <span class="dt">Term</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">App</span> <span class="dt">Term</span> <span class="dt">Term</span></span></code></pre></div>
<p>Each term is interpreted into a <code>Value</code> by a machine (monad) <code>m</code>. Note that lambda-terms are interpreted as monadic functions <code>Value -&gt; M Value</code> and not as functions <code>Value -&gt; Value</code>. This is so we can use these functions to interact with the “machine” using bind.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Value</span> <span class="ot">=</span> <span class="dt">Wrong</span> </span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>           <span class="op">|</span> <span class="dt">Num</span> <span class="dt">Int</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>           <span class="op">|</span> <span class="dt">Fun</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">M</span> <span class="dt">Value</span>)</span></code></pre></div>
<p>If we have free variables, we need to bind them to values before evaluating the term. So we have a type to register this binding:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Environment</span> <span class="ot">=</span> [(<span class="dt">Name</span>, <span class="dt">Value</span>)]</span></code></pre></div>
<h3 id="instance-of-show">Instance of Show</h3>
<p>instance Show Value where show Wrong = “<wrong>” show (Num i) = show i show (Fun f) = “<function>”</p>
<h3 id="functions-defining-the-interpreter">Functions defining the interpreter</h3>
<p>It is convenient to use only monadic functions, even though we don’t need all functions to be monadic.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span><span class="ot"> ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Environment</span> <span class="ot">-&gt;</span> <span class="dt">M</span> <span class="dt">Value</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> x []        <span class="ot">=</span> <span class="fu">return</span> <span class="dt">Wrong</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> x ((y,b)<span class="op">:</span>e) <span class="ot">=</span> <span class="kw">if</span> x<span class="op">==</span>y</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">then</span> <span class="fu">return</span> b</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">else</span> <span class="fu">lookup</span> x e</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">M</span> <span class="dt">Value</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>add (<span class="dt">Num</span> i) (<span class="dt">Num</span> j) <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> <span class="dt">Num</span> (i<span class="op">+</span>j)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>add _ _ <span class="ot">=</span> <span class="fu">return</span> <span class="dt">Wrong</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="ot">apply ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">M</span> <span class="dt">Value</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>apply (<span class="dt">Fun</span> f) a <span class="ot">=</span> f a</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>apply _ _ <span class="ot">=</span> <span class="fu">return</span> <span class="dt">Wrong</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="ot">interp ::</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Environment</span> <span class="ot">-&gt;</span> <span class="dt">M</span> <span class="dt">Value</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>interp (<span class="dt">Con</span> i) e <span class="ot">=</span> <span class="fu">return</span> (<span class="dt">Num</span> i)</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>interp (<span class="dt">Var</span> x) e <span class="ot">=</span> <span class="fu">lookup</span> x e</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>interp (<span class="dt">Add</span> u v) e <span class="ot">=</span> interp u e <span class="op">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> interp v e <span class="op">&gt;&gt;=</span> (\b <span class="ot">-&gt;</span> add a b))</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>interp (<span class="dt">Lam</span> x v) e <span class="ot">=</span> <span class="fu">return</span> (<span class="dt">Fun</span> (\a <span class="ot">-&gt;</span> interp v ((x,a)<span class="op">:</span>e)))</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>interp (<span class="dt">App</span> t u) e <span class="ot">=</span> interp t e <span class="op">&gt;&gt;=</span> (\f <span class="ot">-&gt;</span> interp u e <span class="op">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> apply f a))</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>test t <span class="ot">=</span> <span class="fu">show</span> (interp t [])</span></code></pre></div>
<h2 id="main-examples">Main examples</h2>
<h3 id="machine-0-identity">Machine 0: Identity</h3>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">M</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Id</span> a <span class="ot">=</span> <span class="dt">Id</span> a</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Machine</span> <span class="dt">Id</span> <span class="kw">where</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  returnM a <span class="ot">=</span> <span class="dt">Id</span> a</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  joinM (<span class="dt">Id</span> (<span class="dt">Id</span> a)) <span class="ot">=</span> <span class="dt">Id</span> a</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  fmapM f (<span class="dt">Id</span> a) <span class="ot">=</span> <span class="dt">Id</span> (f a)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Id</span> a) <span class="kw">where</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">Id</span> a) <span class="ot">=</span> <span class="fu">show</span> a</span></code></pre></div>
<h3 id="machine-errors">Machine 1: Error Messages</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- type M = E</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">E</span> a <span class="ot">=</span> <span class="dt">Error</span> <span class="dt">String</span> <span class="op">|</span> <span class="dt">Success</span> a </span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Machine</span> <span class="dt">E</span> <span class="kw">where</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  returnM ::</span> a <span class="ot">-&gt;</span> <span class="dt">E</span> a</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  returnM a <span class="ot">=</span> <span class="dt">Success</span> a</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  joinM ::</span> <span class="dt">E</span> (<span class="dt">E</span> a) <span class="ot">-&gt;</span> <span class="dt">E</span> a</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  joinM (<span class="dt">Success</span> (<span class="dt">Success</span> a)) <span class="ot">=</span> <span class="dt">Success</span> a</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  joinM (<span class="dt">Success</span> (<span class="dt">Error</span> msg)) <span class="ot">=</span> <span class="dt">Error</span> msg</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  joinM (<span class="dt">Error</span> msg)           <span class="ot">=</span> <span class="dt">Error</span> msg</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="ot">  fmapM ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">E</span> a <span class="ot">-&gt;</span> <span class="dt">E</span> b</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>  fmapM f (<span class="dt">Success</span> a) <span class="ot">=</span> <span class="dt">Success</span> (f a)</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>  fmapM f (<span class="dt">Error</span> msg) <span class="ot">=</span> <span class="dt">Error</span> msg</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">E</span> a) <span class="kw">where</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">Success</span> a) <span class="ot">=</span> <span class="fu">show</span> a</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">Error</span> msg) <span class="ot">=</span> <span class="st">&quot;ERROR! &quot;</span> <span class="op">++</span> msg</span></code></pre></div>
<p>Changes to the interpreter:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> x [] <span class="ot">=</span> errorE (<span class="st">&quot;Unbound variable: &quot;</span> <span class="op">++</span> x)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>add a b <span class="ot">=</span> errorE (<span class="st">&quot;Should be numbers: &quot;</span> <span class="op">++</span> <span class="fu">show</span> a <span class="op">++</span> <span class="st">&quot;,&quot;</span> <span class="op">++</span> <span class="fu">show</span> b)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>apply f a <span class="ot">=</span> errorE (<span class="st">&quot;Should be a function: &quot;</span> <span class="op">++</span> <span class="fu">show</span> f)</span></code></pre></div>
<h3 id="machine-count">Machine 2: State</h3>
<p>Our next machine has a changing state that influence and is influenced by the computations. Perhaps this is the most fundamental example.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">StateMachine</span> state a <span class="ot">=</span> <span class="dt">SM</span> (state <span class="ot">-&gt;</span> (a, state))</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Machine</span> (<span class="dt">StateMachine</span> state) <span class="kw">where</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  returnM ::</span> a <span class="ot">-&gt;</span> <span class="dt">StateMachine</span> state a</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  returnM a <span class="ot">=</span> <span class="dt">SM</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> (a, s)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  joinM ::</span> <span class="dt">StateMachine</span> state (<span class="dt">StateMachine</span> state a) <span class="ot">-&gt;</span> <span class="dt">StateMachine</span> state a</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  joinM (<span class="dt">SM</span> metaMachine) <span class="ot">=</span> <span class="dt">SM</span> newMachine</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>      newMachine s0 <span class="ot">=</span> <span class="kw">let</span> (<span class="dt">SM</span> machine, s1) <span class="ot">=</span> metaMachine s0 <span class="kw">in</span> machine s1</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="ot">  fmapM ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">StateMachine</span> state a <span class="ot">-&gt;</span> <span class="dt">StateMachine</span> state b</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>  fmapM f (<span class="dt">SM</span> machine) <span class="ot">=</span> <span class="dt">SM</span> newMachine</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>      newMachine s0 <span class="ot">=</span> <span class="kw">let</span> (a, s1) <span class="ot">=</span> machine s0 <span class="kw">in</span> (f a, s1)</span></code></pre></div>
<p>For our interpreter, we will use as state an <code>Int</code> that counts how man times function is applied or an addition is performed. To this end, we will need the following piece of machinery:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tick ::</span> <span class="dt">StateMachine</span> <span class="dt">Int</span> ()</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>tick <span class="ot">=</span> <span class="dt">SM</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> ((), s<span class="op">+</span><span class="dv">1</span>)</span></code></pre></div>
<p>The typing of <code>tick</code> makes clear that the value returned is not of interest. It is analogous to the use in an impure language of a function that returns nothing, indicating that the purpose of the function lies in a side effect.</p>
<p>Then, we add the following changes in our interpreter:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>apply (<span class="dt">Fun</span> f) a <span class="ot">=</span> tick <span class="op">&gt;&gt;=</span> (\() <span class="ot">-&gt;</span> f a)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>add (<span class="dt">Num</span> i) (<span class="dt">Num</span> j) <span class="ot">=</span> tick <span class="op">&gt;&gt;=</span> (\() <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">Num</span> (i<span class="op">+</span>j)))</span></code></pre></div>
<p>Finally, we only define an instance of <code>Show</code> for the case <code>state</code> is <code>Int</code> (this definition relies in the <code>FlexibleInstances</code> addon):</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">StateMachine</span> <span class="dt">Int</span> a) <span class="kw">where</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">SM</span> machine) <span class="ot">=</span> <span class="kw">let</span> (a, s1) <span class="ot">=</span> machine <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>                      <span class="st">&quot;Value: &quot;</span> <span class="op">++</span> <span class="fu">show</span> a <span class="op">++</span> <span class="st">&quot;; &quot;</span> <span class="op">++</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>                      <span class="st">&quot;Count: &quot;</span> <span class="op">++</span> <span class="fu">show</span> s1</span></code></pre></div>
<p>Now <code>test term0</code> evaluates to <code>"Value: 42; Count: 3"</code>.</p>
<h4 id="variation">Variation</h4>
<p>An interesting variation of our lambda calculus is to be able to refer to hidden state. For this we need to modify our <code>Term</code> definition by adding the <code>Count</code> data constructor:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Count</span></span></code></pre></div>
<p>To read the current state, we use the following:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fetch ::</span> <span class="dt">StateMachine</span> state state</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>fetch <span class="ot">=</span> <span class="dt">SM</span> machine</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    machine s <span class="ot">=</span> (s, s)</span></code></pre></div>
<p>Finally, we add the following line to <code>interp</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>interp <span class="dt">Count</span> e <span class="ot">=</span> fetch <span class="op">&gt;&gt;=</span> (\i <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">Num</span> i))</span></code></pre></div>
<p>Then the term <code>Add (Add (Con 1) (Con 2)) Count</code> will evaluate to 4.</p>
<h3 id="machine-example">Machine 3: Output</h3>
<h3 id="machine-4-non-deterministic-choice">Machine 4: Non-deterministic choice</h3>
<h2 id="more-examples">More examples</h2>
<h3 id="machine-5-errors-with-position">Machine 5: Errors with position</h3>
<h3 id="machine-6-reverse-state">Machine 6: Reverse State</h3>
<h1 id="the-monad-laws">The monad laws</h1>
<h2 id="with-return-join-and-fmap">With <code>return</code>, <code>join</code> and <code>fmap</code></h2>
<h2 class="unnumbered" id="with-bind-monad-composition">With <code>bind</code>; Monad composition</h2>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-Mog89" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">1. </div><div class="csl-right-inline">Moggi, E.: Notions of computation and monads (Selections from 1989 IEEE Symposium on Logic in Computer Science). Information and Computation. 93, 55–92 (1991)</div>
</div>
<div id="ref-Wad90" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">2. </div><div class="csl-right-inline">Wadler, P.: Comprehending monads. In: Proceedings of the 1990 ACM conference on LISP and functional programming. pp. 61–78 (1990)</div>
</div>
<div id="ref-Wad92" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">3. </div><div class="csl-right-inline">Wadler, P.: The essence of functional programming. In: Proceedings of the 19th ACM SIGPLAN-SIGACT symposium on principles of programming languages. pp. 1–14 (1992)</div>
</div>
</div>
</body>
</html>
